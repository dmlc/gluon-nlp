hpf/ja:	NO_KP
extensions	NO_KP
of	BEGIN_KP
high	INSIDE_KP
performance	INSIDE_KP
fortran	INSIDE_KP
for	NO_KP
accelerating	NO_KP
real-world	NO_KP
applications	NO_KP
this	NO_KP
paper	NO_KP
presents	NO_KP
a	NO_KP
set	NO_KP
of	BEGIN_KP
extensions	NO_KP
on	NO_KP
high	BEGIN_KP
performance	INSIDE_KP
fortran	INSIDE_KP
(hpf)	NO_KP
to	NO_KP
make	NO_KP
it	NO_KP
more	NO_KP
usable	NO_KP
for	NO_KP
parallelizing	NO_KP
real-world	NO_KP
production	NO_KP
codes.	NO_KP
hpf	BEGIN_KP
has	NO_KP
been	NO_KP
effective	NO_KP
for	NO_KP
programs	NO_KP
that	NO_KP
a	NO_KP
compiler	BEGIN_KP
can	NO_KP
automatically	NO_KP
optimize	NO_KP
efficiently.	NO_KP
however,	NO_KP
once	NO_KP
the	NO_KP
compiler	BEGIN_KP
cannot,	NO_KP
there	NO_KP
have	NO_KP
been	NO_KP
no	NO_KP
ways	NO_KP
for	NO_KP
the	NO_KP
users	NO_KP
to	NO_KP
explicitly	NO_KP
parallelize	NO_KP
or	NO_KP
optimize	NO_KP
their	NO_KP
programs.	NO_KP
in	NO_KP
order	NO_KP
to	NO_KP
resolve	NO_KP
the	NO_KP
situation,	NO_KP
we	NO_KP
have	NO_KP
developed	NO_KP
a	NO_KP
set	NO_KP
of	BEGIN_KP
hpf	INSIDE_KP
extensions	NO_KP
(hpf/ja)	NO_KP
to	NO_KP
give	NO_KP
the	NO_KP
users	NO_KP
more	NO_KP
control	NO_KP
over	NO_KP
sophisticated	NO_KP
parallelization	BEGIN_KP
and	NO_KP
communication	NO_KP
optimizations.	NO_KP
they	NO_KP
include	NO_KP
parallelization	BEGIN_KP
of	INSIDE_KP
loops	INSIDE_KP
with	NO_KP
complicated	NO_KP
reductions,	NO_KP
asynchronous	NO_KP
communication,	NO_KP
user-controllable	NO_KP
shadow,	NO_KP
and	NO_KP
communication	NO_KP
pattern	NO_KP
reuse	NO_KP
for	NO_KP
irregular	NO_KP
remote	NO_KP
data	BEGIN_KP
accesses.	NO_KP
preliminary	NO_KP
experiments	NO_KP
have	NO_KP
proved	NO_KP
that	NO_KP
the	NO_KP
extensions	NO_KP
are	NO_KP
effective	NO_KP
at	NO_KP
increasing	NO_KP
hpf's	NO_KP
usability	NO_KP
